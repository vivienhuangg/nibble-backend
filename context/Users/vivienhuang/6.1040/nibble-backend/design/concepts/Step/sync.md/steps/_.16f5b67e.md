---
timestamp: 'Wed Nov 05 2025 16:20:27 GMT-0500 (Eastern Standard Time)'
parent: '[[../20251105_162027.06b50472.md]]'
content_id: 16f5b67e3b4c6e5779aa83491fb2acb2bc53f4ca5298152eb4cbd153dcd61469
---

# Architecture Overview

The concept design approach structures its architecture entirely around two fundamental building blocks:

1. **Concepts**: Self-contained, modular increments of functionality (e.g., `Sessioning`, `Posting`, `Commenting`).
2. **Synchronizations**: The rules that orchestrate interactions *between* concepts (e.g., "when a post is deleted, delete all its comments").

## Directory Structure

> **Important:** You should only need to add code within the `src/concepts` and `src/syncs` directories.

```
context/
design/
src/
├── concepts/       <-- YOUR CONCEPTS HERE
│   ├── Sessioning/
│   │   └── SessioningConcept.ts
│   ├── Posting/
│   │   └── PostingConcept.ts
│   └── ...
├── syncs/          <-- YOUR SYNCHRONIZATIONS HERE
│   ├── auth.sync.ts
│   └── posts.sync.ts
│
├── engine/         <-- Framework-provided (ignore)
├── utils/          <-- Framework-provided (ignore)
└── main.ts         <-- Entry-point (can configure logging)
```

## The `Requesting` Concept: Application Entry-point

The architecture will automatically spin up an HTTP server for your application. However, you might wonder how exactly an external HTTP request triggers your logic. This is handled by the provided concept called `Requesting`.

When an HTTP request hits the server, the Concept Engine automatically translates it into a `Requesting.request` action. You don't implement this concept; you just use its actions as triggers in your synchronizations.

> **Important:** by default, `Requesting` also includes *passthrough routes* that automatically generate routes for direct access to concept actions and queries. Please read the [Requesting README](../../src/concepts/Requesting/README.md) for more details.

For example, an incoming request like `POST /api/posts/create` with a JSON body `{ "title": "My First Post", "content": "Hello world!", "session": "s123" }` is automatically converted into an action that looks like this:

`Requesting.request({ path: "/posts/create", title: "My First Post", content: "Hello world!", session: "s123" })`

You can then write a [synchronization](implementing-synchronizations.md) to "catch" this action and do something useful with it:

```typescript
// in src/syncs/posts.sync.ts
const CreatePostOnRequest: Sync = ({ title, content, session, user }) => ({
    when: actions(
        // Catches the request from the engine
        [Requesting.request, { path: "/posts/create", title, content, session }, {}],
    ),
    where: (frames) => {
        // Authorizes the request by checking the session
        return frames
            .query(Sessioning.getUser, { session }, { user });
    },
    then: actions(
        // If we got here, we found a logged in user
        [Posting.create, { title, content, author: user }],
    ),
});
```

By creating the `Sessioning` and `Posting` concepts and including this synchronization, you created an operational and authenticated API endpoint for creating posts. The `Requesting` concept encapsulates the concerns surrounding HTTP requests, and therefore abstracted away the need for specifying a HTTP server, controllers, middleware, etc.

## Initialization

1. Configure any environment variables you need in `.env`
2. Build command: `deno run build` to scan and automatically generate imports for concepts/syncs.
3. Start command: `deno run start` to begin your server.

### concept Step

**purpose** provide sequential instructions that guide users through the cooking process.\
**principle** after defining ordered steps for a recipe, users can follow them sequentially to complete the dish.

**state**

* description : String
* notes : Optional\[String] (e.g., "stir until golden brown")

**actions**

* (Steps are embedded data structures within Recipe; their lifecycle is managed by Recipe actions)

### concept Recipe \[User]

**purpose** enable users to capture, share, and preserve cooking instructions with their community.\
**principle** after creating a recipe with ingredients and steps, users can share it with others who can view, annotate, and fork it for their own modifications while the original remains unchanged.

**state**

* id : UUID
* owner : User
* title : String
* description : Optional\[String]
* ingredients : List\[Ingredient]
* steps : List\[Step]
* tags : Set\[String]
* forkedFrom : Optional\[RecipeId] (ID of the recipe this was forked from)
* created : DateTime
* updated : DateTime

**actions**

* `createRecipe(owner, title, ingredients, steps, description?, forkedFrom?) → recipe`\
  requires owner exists; title ≠ ""; ingredients and steps well-formed; if forkedFrom is provided, that recipe must exist\
  effects adds new recipe with empty tag set, sets creation/update times; optionally tracks the parent recipe if forkedFrom is provided
* `addTag(recipe, tag)` requires recipe exists effects tag ∈ recipe.tags
* `removeTag(recipe, tag)` requires tag ∈ recipe.tags effects tag ∉ recipe.tags
* `deleteRecipe(requester, recipe)` requires requester = recipe.owner effects removes recipe and triggers cascade deletion of related Annotations (via sync)
* `updateRecipeDetails(owner, recipe, newTitle?, newDescription?, newIngredients?, newSteps?)` requires owner = recipe.owner effects updates specified fields and `updated` timestamp
* `draftRecipeWithAI(author, recipe, goal) → (draftId, baseRecipe, requester, goal, ingredients, steps, notes, confidence?, created, expires) | error`\
  requires recipe exists; goal ≠ ""; GEMINI\_API\_KEY is set\
  effects calls Gemini AI with the recipe data and goal; returns draft data that can be applied to modify the recipe
* `applyDraft(owner, recipe, draftDetails) → Empty | error`\
  requires owner = recipe.owner; draft details must be well-formed\
  effects updates the recipe's ingredients and steps with the draft content; adds notes to description; updates timestamp

**queries**

* `_getRecipeById(recipe) → recipe: RecipeDoc | error`\
  requires recipe exists\
  effects returns the full Recipe document
* `_listRecipesByOwner(owner) → recipe: RecipeDoc[] | error`\
  requires owner exists\
  effects returns all recipes owned by the specified user
* `_searchRecipesByTag(tag) → recipe: RecipeDoc[] | error`\
  requires tag is non-empty\
  effects returns all recipes containing the specified tag
* `_getForkCount(recipe) → count | error`\
  requires recipe exists\
  effects returns the count of recipes that have been forked from the specified recipe
* `_listForksOfRecipe(recipe) → recipe: RecipeDoc[] | error`\
  requires recipe exists\
  effects returns all recipes that have been forked from the specified recipe
