---
timestamp: 'Wed Nov 05 2025 16:13:19 GMT-0500 (Eastern Standard Time)'
parent: '[[../20251105_161319.e262198d.md]]'
content_id: 2618edba630177040b59d15047ec01fd9b62d08d2d689d3111b0017cad515d27
---

# response:

Here's an implementation of a synchronization file (`src/syncs/recipe.sync.ts`) for the `Recipe` concept, along with assumed minimal structures for `SessioningConcept` and `AnnotationConcept` to enable these synchronizations.

**1. Assumed Minimal Concept Structures (for imports)**

To allow the synchronizations to properly import and reference other concepts, we'll assume the following minimal structures for `SessioningConcept` and `AnnotationConcept` are available in their respective files (e.g., `src/concepts/Sessioning/SessioningConcept.ts`, `src/concepts/Annotation/AnnotationConcept.ts`). These are placeholders, and you'd replace them with your full implementations.

**`src/concepts/Sessioning/SessioningConcept.ts`**

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";

const PREFIX = "Sessioning" + ".";

export type User = ID;
export type Session = ID;

interface SessionDoc {
  _id: Session;
  user: User;
  // Add other session state properties here if needed
}

export default class SessioningConcept {
  sessions: Collection<SessionDoc>;

  constructor(private readonly db: Db) {
    this.sessions = this.db.collection(PREFIX + "sessions");
  }

  /**
   * _getUser (session: Session) : (user: User)
   *
   * **requires** session exists
   *
   * **effects** returns the user associated with the session
   */
  async _getUser(
    { session }: { session: Session },
  ): Promise<Array<{ user: User } | { error: string }>> {
    const sessionDoc = await this.sessions.findOne({ _id: session });
    if (!sessionDoc) {
      return [{ error: "Session not found" }];
    }
    return [{ user: sessionDoc.user }];
  }

  // Add other Sessioning actions/queries here
}
```

**`src/concepts/Annotation/AnnotationConcept.ts`**

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";

const PREFIX = "Annotation" + ".";

export type RecipeId = ID;
export type AnnotationId = ID;
export type User = ID; // Assuming User is shared type

interface AnnotationDoc {
  _id: AnnotationId;
  recipeId: RecipeId;
  owner: User;
  text: string;
  // Add other annotation state properties here
}

export default class AnnotationConcept {
  annotations: Collection<AnnotationDoc>;

  constructor(private readonly db: Db) {
    this.annotations = this.db.collection(PREFIX + "annotations");
  }

  /**
   * deleteByRecipe (recipeId: RecipeId): Empty
   *
   * **requires** recipeId exists (implicitly handled by calling sync)
   *
   * **effects** deletes all annotations where target recipe is recipeId
   */
  async deleteByRecipe(
    { recipeId }: { recipeId: RecipeId },
  ): Promise<Empty | { error: string }> {
    const result = await this.annotations.deleteMany({ recipeId: recipeId });
    if (result.acknowledged) {
      return {};
    }
    return { error: "Failed to delete annotations" };
  }

  /**
   * _getAnnotationsByRecipe (recipeId: RecipeId) : (annotationId: AnnotationId)
   *
   * **requires** recipeId exists
   *
   * **effects** returns all annotations for the given recipe ID
   */
  async _getAnnotationsByRecipe(
    { recipeId }: { recipeId: RecipeId },
  ): Promise<Array<{ annotationId: AnnotationId } | { error: string }>> {
    const docs = await this.annotations.find({ recipeId }).toArray();
    return docs.map(doc => ({ annotationId: doc._id }));
  }

  // Add other Annotation actions/queries here
}
```

**`src/concepts/Recipe/RecipeConcept.ts`**

You would have a similar structure for your `RecipeConcept`. For the sync file, we just need to know its actions and queries.

**`src/concepts/concepts.ts`**

This file, typically auto-generated by `deno run build`, acts as a central export for all concepts:

```typescript
// src/concepts/concepts.ts (Example auto-generated content)
import SessioningConcept from "./Sessioning/SessioningConcept.ts";
import RequestingConcept from "./Requesting/RequestingConcept.ts";
import RecipeConcept from "./Recipe/RecipeConcept.ts";
import AnnotationConcept from "./Annotation/AnnotationConcept.ts";

export const Sessioning = SessioningConcept;
export const Requesting = RequestingConcept;
export const Recipe = RecipeConcept;
export const Annotation = AnnotationConcept; // For cascade deletion
```

***

**2. Synchronization File: `src/syncs/recipe.sync.ts`**

This file contains the synchronizations that orchestrate interactions involving the `Recipe` concept, handling API requests, authentication, authorization, and cascade deletions.

```typescript
// src/syncs/recipe.sync.ts

// These two help you declare synchronizations
import { actions, Frames, Sync } from "@engine";
// Choose whatever concepts you have
import { Requesting, Sessioning, Recipe, Annotation } from "@concepts";

// --- Create Recipe Synchronizations ---

/**
 * Sync CreateRecipeRequest
 * When a Requesting.request for /recipes/create comes in,
 * authenticate the session to get the owner, then call Recipe.createRecipe.
 */
export const CreateRecipeRequest: Sync = (
  { request, session, owner, title, ingredients, steps, description, forkedFrom },
) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/recipes/create", session, title, ingredients, steps, description, forkedFrom },
      { request },
    ],
  ),
  where: async (frames) => {
    // Authenticate user session to get the owner
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user: owner });
    if (frames.length === 0) {
      return new Frames({ ...originalFrame, error: "Invalid session" });
    }
    return frames;
  },
  then: actions(
    [Recipe.createRecipe, { owner, title, ingredients, steps, description, forkedFrom }],
  ),
});

/**
 * Sync CreateRecipeResponse
 * When a Requesting.request for /recipes/create successfully leads to Recipe.createRecipe,
 * respond to the original request with the new recipe ID.
 */
export const CreateRecipeResponse: Sync = ({ request, recipe }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/create" }, { request }],
    [Recipe.createRecipe, {}, { recipe }],
  ),
  then: actions(
    [Requesting.respond, { request, recipe }],
  ),
});

/**
 * Sync CreateRecipeErrorResponse
 * When a Requesting.request for /recipes/create results in an error from Recipe.createRecipe,
 * respond to the original request with the error.
 */
export const CreateRecipeErrorResponse: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/create" }, { request }],
    [Recipe.createRecipe, {}, { error }],
  ),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});

/**
 * Sync CreateRecipeSessionErrorResponse
 * Catches session-related errors propagated from the `where` clause of `CreateRecipeRequest`.
 */
export const CreateRecipeSessionErrorResponse: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/create" }, { request }],
  ),
  where: (frames) => frames.filter(($) => $[error] === "Invalid session"),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});


// --- Get My Recipes Synchronizations ---

/**
 * Sync ListMyRecipesRequest
 * When a Requesting.request for /recipes/my comes in,
 * authenticate the session to get the owner, then query Recipe._listRecipesByOwner.
 */
export const ListMyRecipesRequest: Sync = (
  { request, session, owner, recipes },
) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/my", session }, { request }],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];
    // Authenticate user session to get the owner
    frames = await frames.query(Sessioning._getUser, { session }, { user: owner });
    if (frames.length === 0) {
      return new Frames({ ...originalFrame, error: "Invalid session" });
    }

    // Query for recipes by owner. `recipes` will be bound to an array of RecipeDoc.
    frames = await frames.query(Recipe._listRecipesByOwner, { owner }, { recipe: recipes });

    // If no recipes are found, ensure a response with an empty array.
    // The `_listRecipesByOwner` query might return an empty array, which still produces a frame,
    // but if the query itself failed (e.g. `owner` not found by `_listRecipesByOwner` though
    // it was validated by Sessioning._getUser), frames could become empty.
    // However, conceptually _listRecipesByOwner should always return a (possibly empty) array.
    if (frames.length === 0) { // This might happen if query function itself returns empty frames due to some internal logic error rather than just an empty array
        return new Frames({ ...originalFrame, [recipes]: [] });
    }
    return frames;
  },
  then: actions(
    [Requesting.respond, { request, recipes }],
  ),
});

/**
 * Sync ListMyRecipesSessionErrorResponse
 * Catches session-related errors propagated from the `where` clause of `ListMyRecipesRequest`.
 */
export const ListMyRecipesSessionErrorResponse: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/my" }, { request }],
  ),
  where: (frames) => frames.filter(($) => $[error] === "Invalid session"),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});


// --- Get Recipe by ID Synchronizations ---

/**
 * Sync GetRecipeByIdRequest
 * When a Requesting.request for /recipes/:recipeId comes in,
 * query Recipe._getRecipeById and respond with the recipe document or a custom error.
 */
export const GetRecipeByIdRequest: Sync = (
  { request, recipe, recipeDoc }, // `recipe` is the ID from the path parameter
) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/:recipeId", recipe }, { request }],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];
    // Query for the recipe by ID
    frames = await frames.query(Recipe._getRecipeById, { recipe }, { recipe: recipeDoc });
    
    if (frames.length === 0) {
      // If recipe not found (query returned empty frames), create a frame with a custom error
      return new Frames({ ...originalFrame, error: "Recipe not found" });
    }
    return frames;
  },
  then: actions(
    [Requesting.respond, { request, recipe: recipeDoc }],
  ),
});

/**
 * Sync GetRecipeByIdResponseError
 * Handles errors returned directly by the Recipe._getRecipeById query.
 */
export const GetRecipeByIdResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/:recipeId" }, { request }],
    [Recipe._getRecipeById, {}, { error }], // Error from query
  ),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});

/**
 * Sync GetRecipeByIdNotFoundResponse
 * Handles the specific "Recipe not found" error created in `GetRecipeByIdRequest`'s where clause.
 */
export const GetRecipeByIdNotFoundResponse: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/recipes/:recipeId" }, { request }],
    ),
    where: (frames) => frames.filter(($) => $[error] === "Recipe not found"),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});


// --- Delete Recipe Synchronizations ---

/**
 * Sync DeleteRecipeRequest
 * When a Requesting.request for /recipes/delete comes in,
 * authenticate session, check recipe ownership, then call Recipe.deleteRecipe.
 */
export const DeleteRecipeRequest: Sync = (
  { request, session, recipe, recipeDoc, requester }, // `recipe` is the ID to delete
) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/delete", recipe, session }, { request }],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];

    // 1. Authenticate user session to get the requester
    frames = await frames.query(Sessioning._getUser, { session }, { user: requester });
    if (frames.length === 0) {
        return new Frames({ ...originalFrame, error: "Invalid session" });
    }

    // 2. Get recipe details to check ownership
    const frameAfterRequester = frames[0]; // Capture frame after getting requester
    frames = await frames.query(Recipe._getRecipeById, { recipe }, { recipe: recipeDoc });
    if (frames.length === 0) {
        return new Frames({ ...frameAfterRequester, error: "Recipe not found" });
    }

    // 3. Filter frames where requester is the recipe owner
    frames = frames.filter(($) => $[requester] === $[recipeDoc].owner);
    if (frames.length === 0) {
        // If the filter resulted in empty frames, it means unauthorized
        return new Frames({ ...frameAfterRequester, error: "Unauthorized to delete this recipe" });
    }
    return frames;
  },
  then: actions(
    [Recipe.deleteRecipe, { requester, recipe }],
  ),
});

/**
 * Sync DeleteRecipeResponse
 * Responds to a successful recipe deletion.
 */
export const DeleteRecipeResponse: Sync = ({ request, recipe }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/delete" }, { request }],
    [Recipe.deleteRecipe, {}, {}], // deleteRecipe action returns empty on success
  ),
  then: actions(
    [Requesting.respond, { request, status: "Recipe deleted successfully", recipe }],
  ),
});

/**
 * Sync DeleteRecipeErrorResponse
 * Handles errors returned directly by the Recipe.deleteRecipe action.
 */
export const DeleteRecipeErrorResponse: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/delete" }, { request }],
    [Recipe.deleteRecipe, {}, { error }],
  ),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});

/**
 * Sync DeleteRecipeCustomErrorResponse
 * Handles specific errors (invalid session, not found, unauthorized) propagated from `DeleteRecipeRequest`.
 */
export const DeleteRecipeCustomErrorResponse: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/recipes/delete" }, { request }],
    ),
    where: (frames) => {
        return frames.filter(($) => 
            $[error] === "Invalid session" ||
            $[error] === "Recipe not found" ||
            $[error] === "Unauthorized to delete this recipe"
        );
    },
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});


// --- Cascade Deletion of Annotations Sync ---

/**
 * Sync CascadeAnnotationDeletion
 * When a Recipe.deleteRecipe action occurs,
 * trigger Annotation.deleteByRecipe to remove all associated annotations.
 */
export const CascadeAnnotationDeletion: Sync = ({ recipe }) => ({
  when: actions(
    [Recipe.deleteRecipe, { recipe }, {}], // When a recipe is deleted
  ),
  // The Annotation.deleteByRecipe action already handles deleting all annotations
  // for a given recipe ID, so no specific 'where' clause to iterate annotations is needed here.
  then: actions(
    [Annotation.deleteByRecipe, { recipeId: recipe }],
  ),
});

// --- Other Recipe Actions (Examples for update, addTag, etc.) ---
// You would follow similar patterns for other actions.

/**
 * Sync UpdateRecipeDetailsRequest
 * Handles request to update recipe details, requires authentication and authorization.
 */
export const UpdateRecipeDetailsRequest: Sync = (
  { request, session, recipe, newTitle, newDescription, newIngredients, newSteps, owner, recipeDoc, requester },
) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/recipes/update", session, recipe, newTitle, newDescription, newIngredients, newSteps },
      { request },
    ],
  ),
  where: async (frames) => {
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user: requester });
    if (frames.length === 0) return new Frames({ ...originalFrame, error: "Invalid session" });

    const frameAfterRequester = frames[0];
    frames = await frames.query(Recipe._getRecipeById, { recipe }, { recipe: recipeDoc });
    if (frames.length === 0) return new Frames({ ...frameAfterRequester, error: "Recipe not found" });

    frames = frames.filter(($) => $[requester] === $[recipeDoc].owner);
    if (frames.length === 0) return new Frames({ ...frameAfterRequester, error: "Unauthorized to update this recipe" });
    
    return frames;
  },
  then: actions(
    [Recipe.updateRecipeDetails, { owner: requester, recipe, newTitle, newDescription, newIngredients, newSteps }],
  ),
});

/**
 * Sync UpdateRecipeDetailsResponse
 */
export const UpdateRecipeDetailsResponse: Sync = ({ request, recipe }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/update" }, { request }],
    [Recipe.updateRecipeDetails, {}, {}], // updateRecipeDetails returns Empty on success
  ),
  then: actions(
    [Requesting.respond, { request, status: "Recipe updated successfully", recipe }],
  ),
});

/**
 * Sync UpdateRecipeDetailsErrorResponse
 * Handles errors from `Recipe.updateRecipeDetails` or custom errors from `where` clause.
 */
export const UpdateRecipeDetailsErrorResponse: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/recipes/update" }, { request }],
    [Recipe.updateRecipeDetails, {}, { error }], // Direct error from action
  ),
  then: actions(
    [Requesting.respond, { request, error }],
  ),
});

export const UpdateRecipeDetailsCustomErrorResponse: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/recipes/update" }, { request }],
    ),
    where: (frames) => frames.filter(($) => 
            $[error] === "Invalid session" ||
            $[error] === "Recipe not found" ||
            $[error] === "Unauthorized to update this recipe"
        ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});
```
